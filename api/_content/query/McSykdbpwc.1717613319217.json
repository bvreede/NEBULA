[{"_path":"/modules/researchsoftware/software-and-data","_dir":"researchsoftware","_draft":false,"_partial":false,"_locale":"","title":"Software is data","description":"","type":"reading","order":6,"_type":"markdown","_id":"local_fs:modules:researchsoftware:software-and-data.md","_source":"local_fs","_file":"modules/researchsoftware/software-and-data.md","_extension":"md","plainText":"---\ntitle: Software is data\ntype: reading\norder: 6\n---\n\n### Software is data (10 minutes, optional)\nIn computer science, the fact that software is data is considered one of the fundamental concepts of computing. The fact that the thing that operates the machine (software) is the same kind of thing as the thing it operates on (data) is definitely one of the strengths of current computersystems and one of the main reasons why we can do such complex and powerful things with the combination of hardware and software.\n\nRead the following blogpost about why this concept is so powerful:\nhttps://www.blackliszt.com/2014/04/fundamental-concepts-of-computing-software-is-data.html\n\n\n### Software is a special type of data ()\nHowever for most practical purposes in most domains of scientific research (except maybe the domain of computer science) it is useful to make a distinction between the data that is software and other data. From now on, when we use the word data, we mean the kind fo data which is not software and which we use to store more static information.\n\n- Software is executable, data is not.\n- Data provides information or evidence, software provides a tool to do work on the data.\n- Software is a creative work, scientific data are facts or observations.\n- The lifetime of software is generally not as long as that of data.\n\n\nhttps://github.com/danielskatz/software-vs-data\n\nhttps://doi.org/10.7287/peerj.preprints.2630v1\n\n\n### Discussion\n\n- \n- Can you think of examples where the line between software and data becomes fuzzy?\n"},{"_path":"/modules/smp/exercise2","_dir":"smp","_draft":false,"_partial":false,"_locale":"","title":"Exercise 2","description":"In a live setting, this exercise is done in groups.\nEach group will be assigned a software project.\nThe group will then create an SMP for this project.","type":"exercise","order":3,"_type":"markdown","_id":"local_fs:modules:smp:exercise2.md","_source":"local_fs","_file":"modules/smp/exercise2.md","_extension":"md","plainText":"---\ntitle: Exercise 2\ntype: exercise\norder: 3\n---\n\n# Exercise 2\n\n*In a live setting, this exercise is done in groups.\nEach group will be assigned a software project.\nThe group will then create an SMP for this project.*\n\n## Step 1: Choose a software project\n\nChoose a software project for this exercise, preferably one you are familiar with.\n\nIf you don't have a project in mind, you can use one of the following:\n- [Xenon](https://research-software-directory.org/software/xenon)\n- [ESMValTool](https://research-software-directory.org/software/esmvaltool)\n- [RS-DAT](https://research-software-directory.org/projects/rs-dat)\n- [Haddock](https://research-software-directory.org/software/haddock3)\n- [worcs](https://cjvanlissa.github.io/worcs/index.html)\n\nFind the Practical Guide at [tinyurl.com/SMP-guide](https://doi.org/10.5281/zenodo.7589725).\n\n## Step 2: Assess the management level needed\n\n- Look at the software repository or page in the Research Software Directory\n- Assess what level of management the software needs: low, medium, or high.\n\nFor this, use the following considerations (section 5 in [the guide](https://doi.org/10.5281/zenodo.7589725)):\n\n1. **Purpose**. What is the current reason or expected end-use for developing the software?\n2. **Reliability**. The effect of software failure and/or non-maintenance on:\n    - Risk of harm to self or others. This includes injury, privacy violation, bias, and inappropriate content.\n    - Reputation. For example to self, institution or other.\n    - Research, either your own or of others. This effect could be due to an obvious software failure (\"crash\") or a hidden one, for example, returning inconsistent numerical results on different operating systems.\n3. **Maintenance**. The long-term effort needed to maintain the software as long as it might be used as a standalone tool or dependency. This includes maintenance functions that can extend beyond the lifespan of the original development project and includes fixing bugs, dependency management, operating system compatibility, and security issues.\n\nThis may not be a clear-cut decision, but that is fine.\nThe goal is to get a sense of the level of management needed.\nDiscuss with your group and come to a consensus.\n\n## Step 3: Fill in the SMP template\n\nFrom the assessment made in Step 1, get the requirements that match the level of management needed.\n\nCopy a template, and fill it in for your software project."}]